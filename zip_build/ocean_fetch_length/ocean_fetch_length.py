# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OceanFetchLength
                                 A QGIS plugin
 Create ocean wave fetch lines and output it's length
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-01-06
        git sha              : $Format:%H$
        copyright            : (C) 2025 by nedisy
        email                : nedi.sawgo.yogya@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QDialog, QVBoxLayout, QLabel, QSpinBox, QPushButton, QComboBox, QHBoxLayout 
from qgis.core import (
    QgsProject, QgsPointXY, QgsVectorLayer, QgsFeature, QgsGeometry, QgsDistanceArea,
    QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsWkbTypes, QgsLineString
)
from qgis.gui import QgsMapToolEmitPoint
import math
import sys
import os
sys.path.append(os.path.dirname(__file__))  # Add current directory to the Python path
import resources  # Ensure this is in the same directory or correctly referenced


class OceanFetchLength:
    def __init__(self, iface):
        """Plugin initialization."""
        self.iface = iface
        self.action = None
        self.dlg = None
        self.center_point = None
        self.map_tool = None

    def initGui(self):
        """Add the plugin to the QGIS GUI."""
        icon_path = ':/icon'
        self.action = QAction(QIcon(icon_path), "Create Ocean Fetch Lines", self.iface.mainWindow())
        self.action.setObjectName("createOceanFetchLines")
        self.action.setWhatsThis("This will create radial lines ended at shores")
        self.action.setStatusTip("Use this to get fetch lengths for ocean wave hindcasting")
        self.action.triggered.connect(self.run)
        self.iface.addToolBarIcon(self.action)
        self.iface.addPluginToVectorMenu("&Research Tools", self.action)

    def unload(self):
        """Remove the plugin from the QGIS GUI."""
        self.iface.removeToolBarIcon(self.action)
        self.iface.removePluginVectorMenu("&Research Tools", self.action)

    def run(self):
        """Run the plugin."""
        if not self.dlg:
            self.dlg = OceanFetchDialog(self.iface, self)
        else:
            # Update the shoreline layers when reopening the dialog
            self.dlg.updateShorelineLayers()
        
        # Activate the map tool to capture clicks
        self.map_tool = QgsMapToolEmitPoint(self.iface.mapCanvas())
        self.map_tool.canvasClicked.connect(self.setCenterPoint)
        self.iface.mapCanvas().setMapTool(self.map_tool)
        
        self.dlg.show()

    def setCenterPoint(self, point, button):
        """Set the center point and update the dialog."""
        
        project_crs = QgsProject.instance().crs()
        layer_crs = QgsCoordinateReferenceSystem("EPSG:4326")  # WGS84

        # Reproject the point
        point = self.reproject_coordinates(point, project_crs, layer_crs)

        self.center_point = point
        self.iface.mapCanvas().unsetMapTool(self.map_tool)  # Deactivate map tool
        self.map_tool = None
        if self.dlg:
            self.dlg.setCenterPointLabel(point)
    
    def reproject_coordinates(self, point, source_crs, target_crs):
        """
        Reproject coordinates from one CRS to another.
        
        Parameters:
            point (QgsPointXY): The point to transform.
            source_crs (QgsCoordinateReferenceSystem): Source CRS.
            target_crs (QgsCoordinateReferenceSystem): Target CRS.
            
        Returns:
            QgsPointXY: Transformed point.
        """
        transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
        return transform.transform(point)


class OceanFetchDialog(QDialog):
    def __init__(self, iface, plugin):
        """Dialog initialization."""
        super().__init__()
        self.iface = iface
        self.plugin = plugin

        self.setWindowTitle("Ocean Fetch Length")
        self.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.setMinimumWidth(300)

        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        self.initUI()

    def initUI(self):
        """Initialize the UI elements."""
        # Center Point Label
        self.center_label = QLabel("Click on the map to set the center point")
        self.layout.addWidget(self.center_label)

        # Number of Lines Input
        num_lines_layout = QHBoxLayout()
        num_lines_label = QLabel("Number of Lines:")
        self.num_lines_spin = QSpinBox()
        self.num_lines_spin.setRange(1, 360)
        self.num_lines_spin.setValue(32)
        num_lines_layout.addWidget(num_lines_label)
        num_lines_layout.addWidget(self.num_lines_spin)
        self.layout.addLayout(num_lines_layout)

        # Shoreline Layer Selection
        shoreline_layout = QHBoxLayout()
        shoreline_label = QLabel("Shoreline Layer:")
        self.shoreline_combo = QComboBox()
        self.updateShorelineLayers()
        shoreline_layout.addWidget(shoreline_label)
        shoreline_layout.addWidget(self.shoreline_combo)
        self.layout.addLayout(shoreline_layout)

        # Calculate Button
        self.calculate_button = QPushButton("Calculate Fetch Lines")
        self.calculate_button.clicked.connect(self.calculateFetchLines)
        self.layout.addWidget(self.calculate_button)

        # Set up Map Tool
        self.map_tool = QgsMapToolEmitPoint(self.iface.mapCanvas())
        self.map_tool.canvasClicked.connect(self.plugin.setCenterPoint)

    def setCenterPointLabel(self, point):
        """Update the center point label."""
        self.center_label.setText(f"Center Point: {point.x():.4f}, {point.y():.4f}")

    def updateShorelineLayers(self):
        """Populate the shoreline layer combo box."""
        self.shoreline_combo.clear()
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == layer.VectorLayer and layer.geometryType() in [QgsWkbTypes.LineGeometry, QgsWkbTypes.MultiLineString]:
                self.shoreline_combo.addItem(layer.name())

    def calculateFetchLines(self):
        """Calculate fetch lines and add them to the map."""
        if not self.plugin.center_point:
            self.iface.messageBar().pushWarning("Ocean Fetch Length", "Center point not set!")
            return

        num_lines = self.num_lines_spin.value()
        shoreline_layer_name = self.shoreline_combo.currentText()
        shoreline_layer = next((layer for layer in QgsProject.instance().mapLayers().values() if layer.name() == shoreline_layer_name), None)

        if not shoreline_layer:
            self.iface.messageBar().pushWarning("Ocean Fetch Length", "Shoreline layer not found!")
            return
        
        distance = QgsDistanceArea()
        distance.setEllipsoid('WGS84')
        
        fetch_layer = QgsVectorLayer("LineString?crs=EPSG:4326&field=Angle:real&field=Distance:real", "Fetch Lines", "memory")
        pr = fetch_layer.dataProvider()

        center_point = self.plugin.center_point

        for angle in [x * (360 / num_lines) for x in range(0, num_lines)]:
            end_point = self.calculateEndPoint(center_point, angle, 1000000)  # Extend to 1000 km
            intermediate_points = []
            for i in range(999):
                i_length = 1000*(i+1)
                i_point = self.calculateEndPoint(center_point, angle, i_length)
                intermediate_points.append(i_point)
            line_geom = QgsGeometry.fromPolylineXY([center_point] + intermediate_points + [end_point])
            closest_point = self.findClosestIntersection(line_geom, shoreline_layer, center_point, end_point)
            closest_distance = distance.measureLine(center_point, closest_point)
            intermediate_points = intermediate_points[:int(closest_distance//1000)]
            if closest_point:
                new_line = QgsLineString([center_point] + intermediate_points + [closest_point])
                feature = QgsFeature(fetch_layer.fields())
                feature.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(pt.x(), pt.y()) for pt in new_line.points()]))
                feature.setAttribute("Angle", angle)
                feature.setAttribute("Distance", closest_distance)
                pr.addFeature(feature)

        QgsProject.instance().addMapLayer(fetch_layer)


    def calculateEndPoint(self, center, angle, distance):
        """Calculate the endpoint of a line given an angle and distance using WGS84 model."""
        
        # WGS84 ellipsoid parameters
        a = 6378137.0  # Semi-major axis (equatorial radius in meters)
        f = 1 / 298.257223563  # Flattening
        b = a * (1 - f)  # Semi-minor axis (polar radius in meters)
        
        lat1 = math.radians(center.y())  # Starting latitude in radians
        lon1 = math.radians(center.x())  # Starting longitude in radians
        bearing = math.radians(angle)    # Bearing in radians

        # Vincenty's formula for the direct problem on the ellipsoid
        tanU1 = (1 - f) * math.tan(lat1)
        cosU1 = 1 / math.sqrt(1 + tanU1 * tanU1)
        sinU1 = tanU1 * cosU1
        
        sigma1 = math.atan2(tanU1, math.cos(bearing))
        sinAlpha = cosU1 * math.sin(bearing)
        cosSqAlpha = 1 - sinAlpha * sinAlpha
        uSq = cosSqAlpha * (a * a - b * b) / (b * b)
        
        A = 1 + (uSq / 16384) * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))
        B = (uSq / 1024) * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))
        
        sigma = distance / (b * A)
        sigmaP = 2 * math.pi
        
        while abs(sigma - sigmaP) > 1e-12:
            cos2SigmaM = math.cos(2 * sigma1 + sigma)
            sinSigma = math.sin(sigma)
            cosSigma = math.cos(sigma)
            deltaSigma = B * sinSigma * (cos2SigmaM + (B / 4) * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
                                (B / 6) * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)))
            sigmaP = sigma
            sigma = distance / (b * A) + deltaSigma
        
        tmp = sinU1 * sinSigma - cosU1 * cosSigma * math.cos(bearing)
        lat2 = math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * math.cos(bearing),
                          (1 - f) * math.sqrt(sinAlpha * sinAlpha + tmp * tmp))
        
        lambdaL = math.atan2(math.sin(bearing) * sinSigma * cosU1,
                             cosSigma - sinU1 * math.sin(lat2))
        
        C = (f / 16) * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha))
        L = lambdaL - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)))

        lon2 = (lon1 + L + 3 * math.pi) % (2 * math.pi) - math.pi  # Normalize to -π..+π

        return QgsPointXY(math.degrees(lon2), math.degrees(lat2))

    def findClosestIntersection(self, line_geom, shoreline_layer, center_point, end_point):
        """
        Find the closest intersection point between a line and the shoreline layer to a given center point.
        
        Parameters:
            line_geom (QgsGeometry): Geometry of the line to check for intersections.
            shoreline_layer (QgsVectorLayer): Layer containing the shoreline features.
            center_point (QgsPointXY): The reference point from which distances are calculated.
            
        Returns:
            QgsPointXY or None: Closest intersection point, or None if no intersection found.
        """
        closest_point = end_point
        min_distance = float('inf')

        for feature in shoreline_layer.getFeatures():
            geom = feature.geometry()
            
            # Ensure shoreline geometry is valid for intersection
            if not geom.isEmpty():
                intersection = line_geom.intersection(geom)  # Perform intersection as QgsGeometry
                
                if not intersection.isEmpty():  # Check if there is an intersection
                    if intersection.isMultipart():
                        points = intersection.asMultiPoint()  # Handle multipart intersection
                    else:
                        points = [intersection.asPoint()]  # Single intersection point

                    for point in points:
                        # Convert QgsPoint to QgsPointXY for consistency if needed
                        point_xy = QgsPointXY(point)
                        # Calculate Euclidean distance between center_point and intersection point
                        dist = center_point.distance(point_xy)
                        if dist < min_distance:
                            min_distance = dist
                            closest_point = point_xy

        return closest_point



def classFactory(iface):
    return OceanFetchLength(iface)